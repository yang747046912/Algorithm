#include "BRtreeHelper.h"void createBRTree(BRtree &root, int *array, int n) {    for (int i = 0; i < n; i++) {        insertBRTree(root, *(array + i));    }}void insertBRTree(BRtree &root, int value) {    stack<BRtree> nodes;    BRtree tmp = root;    while (tmp != NULL && tmp->value != value) {        nodes.push(tmp);        if (tmp->value > value) {            tmp = tmp->leftNode;        } else {            tmp = tmp->rigthNode;        }    }    if (tmp != NULL) {        cout << value << "已经存在，无法插入" << endl;        return;    }    tmp = new BRtreeNode;    tmp->value = value;    tmp->leftNode = NULL;    tmp->rigthNode = NULL;    if (nodes.empty()) {        root = tmp;        root->color = BLACK;        return;    }    BRtree tmpParent = NULL;    tmpParent = nodes.top();    if (tmp->value > tmpParent->value) {        tmpParent->rigthNode = tmp;    } else {        tmpParent->leftNode = tmp;    }    while (!nodes.empty()) {        tmpParent = nodes.top();        if (tmpParent->color == BLACK) {            return;        }        nodes.pop();        if (nodes.empty()) {            if (tmpParent->color == RED) {                tmpParent->color = BLACK;            }            return;        }        BRtree tmpGrand = nodes.top();        BRtree tmpUncle = NULL;        if (tmpParent->value > tmpGrand->value) {            tmpUncle = tmpGrand->leftNode;        } else {            tmpUncle = tmpGrand->rigthNode;        }        if (tmpUncle != NULL && tmpUncle->color == RED) {            tmpParent->color = BLACK;            tmpUncle->color = BLACK;            tmpGrand->color = RED;            tmp = tmpGrand;            nodes.pop();        } else {            if (tmpGrand->leftNode == tmpParent) {                if (tmpParent->leftNode == tmp) {                    roateLL(tmpGrand);                } else {                    roateLR(tmpGrand);                }            } else {                if (tmpParent->rigthNode == tmp) {                    roateRR(tmpGrand);                } else {                    roateRL(tmpGrand);                }            }            tmpGrand->color = BLACK;            tmpGrand->leftNode->color = RED;            tmpGrand->rigthNode->color = RED;            nodes.pop();            if (nodes.empty()) {                root = tmpGrand;            } else {                if (nodes.top()->value > tmpGrand->value) {                    nodes.top()->leftNode = tmpGrand;                } else {                    nodes.top()->rigthNode = tmpGrand;                }            }            return;        }    }}void roateLL(BRtree &root) {    BRtree left = root->leftNode;    root->leftNode = root->rigthNode;    left->rigthNode = root;    root = left;}void roateLR(BRtree &root) {    BRtree left = root->leftNode;    BRtree right = left->rigthNode;    root->leftNode = right->rigthNode;    left->rigthNode = right->leftNode;    right->leftNode = left;    right->rigthNode = root;    root = right;}void roateRR(BRtree &root) {    BRtree right = root->rigthNode;    root->rigthNode = right->leftNode;    right->leftNode = root;    root = right;}void roateRL(BRtree &root) {    BRtree right = root->rigthNode;    BRtree left = right->leftNode;    root->rigthNode = left->leftNode;    right->leftNode = left->rigthNode;    left->leftNode = root;    left->rigthNode = right;    root = left;}void logBRTree(BRtree root) {    if (root != NULL) {        cout << root->value << " ";        logBRTree(root->leftNode);        logBRTree(root->rigthNode);    }}void deleteBRTree(BRtree &root, int value) {    cout<<"删除"<<value<<":"<<endl;    BRtree tmp = root;    stack<BRtree> nodes;    while (tmp != NULL && tmp->value != value) {        nodes.push(tmp);        if (tmp->value > value) {            tmp = tmp->leftNode;        } else {            tmp = tmp->rigthNode;        }    }    if (tmp == NULL) {        cout << value << "不存在，无法删除" << endl;        return;    }    cout << value << "找到，正在删除" << endl;    BRtree minTmp = tmp;//右支树最小值    if (minTmp->leftNode != NULL && minTmp->rigthNode != NULL) {        nodes.push(minTmp);        minTmp = minTmp->rigthNode;        while (minTmp->leftNode != NULL) {            minTmp = minTmp->leftNode;            nodes.push(minTmp);        }        tmp->value = minTmp->value;    }    tmp = minTmp;    BRtree newTmp = tmp->rigthNode;    if (newTmp == NULL) {        newTmp == tmp->leftNode;    }    if (nodes.empty()) {//根节点被删除        root = newTmp;        if (root != NULL) {            root->color = BLACK;        }        return;    } else {        BRtree tmpParent = nodes.top();        if (tmpParent->value > tmp->value) {            tmpParent->leftNode = newTmp;        } else {            tmpParent->rigthNode = newTmp;        }        if (tmp->color == BLACK && newTmp != NULL && newTmp->color == RED) {            newTmp->color = BLACK;            return;        }    }    if (tmp->color == RED) {        return;    }    nodes.pop();    nodes.push(newTmp);    while (!nodes.empty()) {        BRtree current = nodes.top();        nodes.pop();        if (nodes.empty()) {            return;        }        BRtree currentParent = nodes.top();        nodes.pop();        BRtree currentUncle = NULL;        if (currentParent->value > current->value) {            currentUncle = currentParent->rigthNode;        } else {            currentUncle = currentParent->leftNode;        }        if (currentUncle != NULL && currentUncle->color == RED) {//红兄            currentUncle->color = BLACK;            currentParent->color = RED;            if (currentParent->value > currentUncle->value) {                roateLL(currentParent);            } else {                roateRR(currentParent);            }            if (nodes.empty()) {                root = currentParent;                currentParent->color = BLACK;                return;            } else {                if (nodes.top()->value > currentParent->value) {                    nodes.top()->leftNode = currentParent;                } else {                    nodes.top()->rigthNode = currentParent;                }            }        } else {//黑兄            if (isBlackOrNull(currentUncle->leftNode) && isBlackOrNull(currentUncle->rigthNode)) {//二黑侄儿                if (currentParent->color == RED) {//红父                    currentParent->color = BLACK;                    currentUncle->color = RED;                    current->color = BLACK;                    return;                } else {//黑父                    if (current != NULL && current->color == RED) {                        currentParent->color = RED;                    } else {                        currentParent->color = BLACK;                    }                    current->color = BLACK ;                    currentUncle->color = RED ;                }            } else{//红侄儿                int parentColor = currentParent->color ;                currentParent->color = BLACK;                if (currentParent->value > currentUncle->value) {                    if (currentUncle->rigthNode!=NULL&&currentUncle->rigthNode->color ==RED){                        currentUncle->rigthNode->color=BLACK ;                        roateRR(currentParent);                    } else{                        roateRL(currentParent);                    }                } else {                    if (currentUncle->leftNode!=NULL&&currentUncle->leftNode->color ==RED){                        currentUncle->leftNode->color=BLACK ;                        roateLL(currentParent);                    } else{                        roateLR(currentParent);                    }                }                currentParent->color=parentColor;                if (nodes.empty()) {                    root = currentParent;                    currentParent->color = BLACK;                    return;                } else {                    if (nodes.top()->value > currentParent->value) {                        nodes.top()->leftNode = currentParent;                    } else {                        nodes.top()->rigthNode = currentParent;                    }                }                return;            }        }    }}bool isBlackOrNull(BRtree root) {    if (root != NULL) {        return root->color == BLACK;    }    return true;}